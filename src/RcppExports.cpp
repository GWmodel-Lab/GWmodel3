// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

// #include <RcppArmadillo.h>
#include <Rcpp.h>
#include <armadillo>
#include <vector>
#include <utility>
#include <string>
#include "gwmodel.h"

using namespace std;
using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

inline arma::mat rtoa(const NumericMatrix& rmat)
{
    return arma::mat(rmat.begin(), rmat.nrow(), rmat.ncol());
}

inline arma::vec rtoa(const NumericVector& rvec)
{
    return arma::vec(rvec.begin(), rvec.size());
}

inline SEXP ator(const arma::mat& amat)
{
    RObject x = wrap(amat.begin(), amat.end());
    x.attr("dim") = Dimension(amat.n_rows, amat.n_cols);
    return x;
}

inline SEXP ator(const arma::vec& avec)
{
    RObject x = wrap(avec.begin(), avec.end());
    return x;
}

List wrap(const GwmRegressionDiagnostic& diagnostic)
{
    return List::create(
        Named("RSS") = diagnostic.RSS,
        Named("AIC") = diagnostic.AIC,
        Named("AICc") = diagnostic.AICc,
        Named("ENP") = diagnostic.ENP,
        Named("EDF") = diagnostic.EDF,
        Named("RSquare") = diagnostic.RSquare,
        Named("RSquareAdjust") = diagnostic.RSquareAdjust
    );
}

List wrap(const VariablesCriterionList& criterion_list)
{
    List model_combinations;
    NumericVector model_criterions;
    for (auto &&item : criterion_list)
    {
        model_combinations.push_back(wrap(item.first));
        model_criterions.push_back(item.second);
    }
    return List::create(
        Named("models") = model_combinations,
        Named("criterions") = model_criterions
    );
}

RcppExport SEXP _GWmodel_gwr_basic(
    SEXP xSEXP, SEXP ySEXP, SEXP coordsSEXP,
    SEXP bwSEXP, SEXP adaptiveSEXP, SEXP kernelSEXP,
    SEXP longlatSEXP, SEXP pSEXP, SEXP thetaSEXP,
    SEXP hatmatrixSEXP, SEXP interceptSEXP, SEXP parallel_typeSEXP, SEXP parallel_argSEXP,
    SEXP optim_bwSEXP, SEXP optim_bw_criterionSEXP,
    SEXP select_modelSEXP, SEXP select_model_criterionSEXP, SEXP select_model_thresholdSEXP)
{
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const NumericMatrix& >::type coords(coordsSEXP);
    Rcpp::traits::input_parameter< double >::type bw(bwSEXP);
    Rcpp::traits::input_parameter< bool >::type adaptive(adaptiveSEXP);
    Rcpp::traits::input_parameter< size_t >::type kernel(kernelSEXP);
    Rcpp::traits::input_parameter< bool >::type longlat(longlatSEXP);
    Rcpp::traits::input_parameter< double >::type p(pSEXP);
    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< bool >::type hatmatrix(hatmatrixSEXP);
    Rcpp::traits::input_parameter< bool >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< size_t >::type parallel_type(parallel_typeSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type parallel_arg(parallel_argSEXP);
    Rcpp::traits::input_parameter< bool >::type optim_bw(optim_bwSEXP);
    Rcpp::traits::input_parameter< size_t >::type optim_bw_criterion(optim_bw_criterionSEXP);
    Rcpp::traits::input_parameter< bool >::type select_model(select_modelSEXP);
    Rcpp::traits::input_parameter< size_t >::type select_model_criterion(select_model_criterionSEXP);
    Rcpp::traits::input_parameter< size_t >::type select_model_threshold(select_model_thresholdSEXP);

    // Convert data types
    arma::mat mx = rtoa(x);
    arma::vec my = rtoa(y);
    arma::mat mcoords = rtoa(coords);
    std::vector<int> vpar_args = as< std::vector<int> >(Rcpp::IntegerVector(parallel_arg));

    // Make Spatial Weight
    CGwmBandwidthWeight bandwidth(bw, adaptive, CGwmBandwidthWeight::KernelFunctionType((size_t)kernel));
    CGwmDistance* distance = nullptr;
    if (longlat)
    {
        distance = new CGwmCRSDistance(true);
    }
    else
    {
        if (p == 2.0 && theta == 0.0)
        {
            distance = new CGwmCRSDistance(false);
        }
        else
        {
            distance = new CGwmMinkwoskiDistance(p, theta);
        }
    }
    CGwmSpatialWeight spatial(&bandwidth, distance);
    
    // Make Algorithm Object
    CGwmGWRBasic algorithm(mx, my, mcoords, spatial, hatmatrix, intercept);
    algorithm.setIsAutoselectIndepVars(select_model);
    algorithm.setIndepVarSelectionThreshold(select_model_threshold);
    algorithm.setIsAutoselectBandwidth(optim_bw);
    algorithm.setBandwidthSelectionCriterion(CGwmGWRBasic::BandwidthSelectionCriterionType(size_t(optim_bw_criterion)));
    switch (ParallelType(size_t(parallel_type)))
    {
    case ParallelType::SerialOnly:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
    case ParallelType::OpenMP:
        algorithm.setParallelType(ParallelType::OpenMP);
        algorithm.setOmpThreadNum(vpar_args[0]);
    default:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
    }
    algorithm.fit();

    // Return Results
    mat betas = algorithm.betas();
    List result_list = List::create(
        Named("betas") = ator(betas),
        Named("betasSE") = ator(algorithm.betasSE()),
        Named("sTrace") = ator(algorithm.sHat()),
        Named("sHat") = ator(algorithm.s()),
        Named("diagnostic") = wrap(algorithm.diagnostic())
    );
    if (optim_bw)
    {
        double bw_value = algorithm.spatialWeight().weight<CGwmBandwidthWeight>()->bandwidth();
        result_list["bandwidth"] = wrap(bw_value);
    }
    if (select_model)
    {
        vector<size_t> sel_vars = algorithm.selectedVariables();
        result_list["variables"] = wrap(sel_vars);
        result_list["model_sel_criterions"] = wrap(algorithm.indepVarsSelectionCriterionList());
        mat x = mx.cols(CGwmVariableForwardSelector::index2uvec(sel_vars, intercept));
        result_list["fitted"] = ator(CGwmGWRBasic::Fitted(x, betas));
    }
    else
    {
        result_list["fitted"] = ator(CGwmGWRBasic::Fitted(mx, betas));
    }

    rcpp_result_gen = result_list;
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_GWmodel_gwr_basic", (DL_FUNC) &_GWmodel_gwr_basic, 18},
    {NULL, NULL, 0}
};

RcppExport void R_init_GWmodel(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
