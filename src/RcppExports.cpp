// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>
#include <RcppArmadilloConfig.h>
#include <armadillo>
#include <gwmodel.h>

using namespace Rcpp;
using namespace arma;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

inline mat rtoa(const NumericMatrix& rmat)
{
    return mat(rmat.begin(), rmat.nrow(), rmat.ncol());
}

inline vec rtoa(const NumericVector& rvec)
{
    return vec(rvec.begin(), rvec.size());
}

inline SEXP ator(const mat& amat)
{
    RObject x = wrap(amat.begin(), amat.end());
    x.attr("dim") = Dimension(amat.n_rows, amat.n_cols);
    return x;
}

inline SEXP ator(const vec& avec)
{
    RObject x = wrap(avec.begin(), avec.end());
    return x;
}

RcppExport SEXP _GWmodel_gwr_basic(
    const NumericMatrix& x, const NumericVector& y, const NumericMatrix& coords,
    const StringVector& indep_vars, const StringVector& dep_var,
    double bw, bool adaptive, int kernel,
    bool longlat, double p, double theta,
    bool hatmatrix,
    int parallel_type, int parallel_arg)
{
    // Convert data types
    mat mx = rtoa(x);
    vec my = rtoa(y);
    mat mcoords = rtoa(coords);
    vector<string> vxfields = as< vector<string> >(indep_vars);
    vector<string> vyfields = as< vector<string> >(dep_var);

    // Make SimpleLayer
    mat mdata = join_cols(my, mx);
    vector<string> vfields = vxfields;
    vfields.insert(vfields.begin(), vyfields.begin(), vyfields.begin() + 1);
    CGwmSimpleLayer layer(mcoords, mdata, vfields);

    // Make Variables
    GwmVariable m_dep_var = {0, true, vyfields[0]};
    vector<GwmVariable> m_indep_vars;
    for (size_t i = 0; i < vxfields.size(); i++)
    {
        GwmVariable indep = {i + 1, true, vxfields[i]};
        m_indep_vars.push_back(indep);
    }
    
    // Make Spatial Weight
    CGwmBandwidthWeight bandwidth {bw, adaptive, (CGwmBandwidthWeight::KernelFunctionType)kernel};
    CGwmDistance* distance = nullptr;
    if (longlat)
    {
        distance = new CGwmCRSDistance(true);
    }
    else
    {
        if (p == 2.0 && theta == 0.0)
        {
            distance = new CGwmCRSDistance(false);
        }
        else
        {
            distance = new CGwmMinkwoskiDistance(p, theta);
        }
    }
    CGwmSpatialWeight spatial(&bandwidth, distance);
    
    // Make Algorithm Object
    CGwmGWRBasic algorithm;
    algorithm.setSourceLayer(layer);
    algorithm.setDependentVariable(m_dep_var);
    algorithm.setIndependentVariables(m_indep_vars);
    algorithm.setSpatialWeight(spatial);
    algorithm.setHasHatMatrix(hatmatrix);
    algorithm.run();

    // Calculate Fitted Values
    mat mbetas = algorithm.betas();
    vec mfitted = CGwmGWRBasic::Fitted(mx, mbetas);

    // Get Diagnostic
    GwmRegressionDiagnostic diagnostic = algorithm.diagnostic();
    List mdiagnostic = List::create(
        Named("RSS") = diagnostic.RSS,
        Named("AIC") = diagnostic.AIC,
        Named("AICc") = diagnostic.AICc,
        Named("ENP") = diagnostic.ENP,
        Named("EDF") = diagnostic.EDF,
        Named("RSquare") = diagnostic.RSquare,
        Named("RSquareAdjust") = diagnostic.RSquareAdjust
    );

    // Return Results
    return List::create(
        Named("betas") = ator(mbetas),
        Named("diagnostic") = mdiagnostic,
        Named("fitted") = ator(mfitted)
    );
}

static const R_CallMethodDef CallEntries[] = {
    {"_GWmodel_gwr_basic", (DL_FUNC) &_GWmodel_gwr_basic, 14},
    {NULL, NULL, 0}
};

RcppExport void R_init_GWmodel(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
