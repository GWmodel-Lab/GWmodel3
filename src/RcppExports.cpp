// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Genermywrap token: 10BE3573-1514-4C36-9D1C-5A225CD40393

// #include <RcppArmadillo.h>
#include <Rcpp.h>
#include <armadillo>
#include <vector>
#include <utility>
#include <string>
#include "gwmodel.h"
#include "gwmodelpp/spatialweight/OneDimDistance.h"
#include "gwmodelpp/Logger.h"

using namespace std;
using namespace Rcpp;
using namespace gwm;
using namespace arma;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

inline arma::mat myas(const NumericMatrix& rmat)
{
    return arma::mat(rmat.begin(), rmat.nrow(), rmat.ncol());
}

inline arma::vec myas(const NumericVector& rvec)
{
    return arma::vec(rvec.begin(), rvec.size());
}

inline SEXP mywrap(const arma::mat& amat)
{
    RObject x = wrap(amat.begin(), amat.end());
    x.attr("dim") = Dimension(amat.n_rows, amat.n_cols);
    return x;
}

inline SEXP mywrap(const arma::vec& avec)
{
    RObject x = wrap(avec.begin(), avec.end());
    return x;
}

List mywrap(const RegressionDiagnostic& diagnostic)
{
    return List::create(
        Named("RSS") = diagnostic.RSS,
        Named("AIC") = diagnostic.AIC,
        Named("AICc") = diagnostic.AICc,
        Named("ENP") = diagnostic.ENP,
        Named("EDF") = diagnostic.EDF,
        Named("RSquare") = diagnostic.RSquare,
        Named("RSquareAdjust") = diagnostic.RSquareAdjust
    );
}

List mywrap(const VariablesCriterionList& criterion_list)
{
    List model_combinations;
    NumericVector model_criterions;
    for (auto &&item : criterion_list)
    {
        model_combinations.push_back(wrap(item.first));
        model_criterions.push_back(item.second);
    }
    return List::create(
        Named("models") = model_combinations,
        Named("criterions") = model_criterions
    );
}

void r_printer(std::string message, Logger::LogLevel level, std::string fun_name, std::string file_name)
{
    switch (level)
    {
    case Logger::LogLevel::LOG_EMERG:
    case Logger::LogLevel::LOG_ALERT:
    case Logger::LogLevel::LOG_CRIT:
    case Logger::LogLevel::LOG_ERR:
        Rcpp::Rcerr << "ERROR: " << message << " [" << fun_name << "]" << " (in " << file_name << ")\n";
        break;
    case Logger::LogLevel::LOG_WARNING:
    case Logger::LogLevel::LOG_NOTICE:
    case Logger::LogLevel::LOG_INFO:
    case Logger::LogLevel::LOG_DEBUG:
    default:
        Rcpp::Rcout << "MSG: " << message << " [" << fun_name << "]" << " (in " << file_name << ")\n";
        break;
    }
}

RcppExport SEXP _GWmodel_gwr_basic_fit(
    SEXP xSEXP, SEXP ySEXP, SEXP coordsSEXP,
    SEXP bwSEXP, SEXP adaptiveSEXP, SEXP kernelSEXP,
    SEXP longlatSEXP, SEXP pSEXP, SEXP thetaSEXP,
    SEXP hatmatrixSEXP, SEXP interceptSEXP, SEXP parallel_typeSEXP, SEXP parallel_argSEXP,
    SEXP optim_bwSEXP, SEXP optim_bw_criterionSEXP,
    SEXP select_modelSEXP, SEXP select_model_criterionSEXP, SEXP select_model_thresholdSEXP)
{
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const NumericMatrix& >::type coords(coordsSEXP);
    Rcpp::traits::input_parameter< double >::type bw(bwSEXP);
    Rcpp::traits::input_parameter< bool >::type adaptive(adaptiveSEXP);
    Rcpp::traits::input_parameter< size_t >::type kernel(kernelSEXP);
    Rcpp::traits::input_parameter< bool >::type longlat(longlatSEXP);
    Rcpp::traits::input_parameter< double >::type p(pSEXP);
    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< bool >::type hatmatrix(hatmatrixSEXP);
    Rcpp::traits::input_parameter< bool >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< size_t >::type parallel_type(parallel_typeSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type parallel_arg(parallel_argSEXP);
    Rcpp::traits::input_parameter< bool >::type optim_bw(optim_bwSEXP);
    Rcpp::traits::input_parameter< size_t >::type optim_bw_criterion(optim_bw_criterionSEXP);
    Rcpp::traits::input_parameter< bool >::type select_model(select_modelSEXP);
    Rcpp::traits::input_parameter< size_t >::type select_model_criterion(select_model_criterionSEXP);
    Rcpp::traits::input_parameter< size_t >::type select_model_threshold(select_model_thresholdSEXP);

    // Logger
    Logger::printer = r_printer;

    // Convert data types
    arma::mat mx = myas(x);
    arma::vec my = myas(y);
    arma::mat mcoords = myas(coords);
    std::vector<int> vpar_args = as< std::vector<int> >(Rcpp::IntegerVector(parallel_arg));

    // Make Spatial Weight
    BandwidthWeight bandwidth(bw, adaptive, BandwidthWeight::KernelFunctionType((size_t)kernel));
    Distance* distance = nullptr;
    if (longlat)
    {
        distance = new CRSDistance(true);
    }
    else
    {
        if (p == 2.0 && theta == 0.0)
        {
            distance = new CRSDistance(false);
        }
        else
        {
            distance = new MinkwoskiDistance(p, theta);
        }
    }
    SpatialWeight spatial(&bandwidth, distance);
    
    // Make Algorithm Object
    GWRBasic algorithm(mx, my, mcoords, spatial, hatmatrix, intercept);
    algorithm.setIsAutoselectIndepVars(select_model);
    algorithm.setIndepVarSelectionThreshold(select_model_threshold);
    algorithm.setIsAutoselectBandwidth(optim_bw);
    algorithm.setBandwidthSelectionCriterion(GWRBasic::BandwidthSelectionCriterionType(size_t(optim_bw_criterion)));
    switch (ParallelType(size_t(parallel_type)))
    {
    case ParallelType::SerialOnly:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
#ifdef _OPENMP
    case ParallelType::OpenMP:
        algorithm.setParallelType(ParallelType::OpenMP);
        algorithm.setOmpThreadNum(vpar_args[0]);
        break;
#endif
    default:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
    }
    algorithm.fit();

    // Return Results
    mat betas = algorithm.betas();
    List result_list = List::create(
        Named("betas") = mywrap(betas),
        Named("betasSE") = mywrap(algorithm.betasSE()),
        Named("sTrace") = mywrap(algorithm.sHat()),
        Named("sHat") = mywrap(algorithm.s()),
        Named("diagnostic") = mywrap(algorithm.diagnostic())
    );
    if (optim_bw)
    {
        double bw_value = algorithm.spatialWeight().weight<BandwidthWeight>()->bandwidth();
        result_list["bandwidth"] = wrap(bw_value);
    }
    if (select_model)
    {
        vector<size_t> sel_vars = algorithm.selectedVariables();
        result_list["variables"] = wrap(sel_vars);
        result_list["model_sel_criterions"] = mywrap(algorithm.indepVarsSelectionCriterionList());
        mat x = mx.cols(VariableForwardSelector::index2uvec(sel_vars, intercept));
        result_list["fitted"] = mywrap(GWRBasic::Fitted(x, betas));
    }
    else
    {
        result_list["fitted"] = mywrap(GWRBasic::Fitted(mx, betas));
    }

    rcpp_result_gen = result_list;
    return rcpp_result_gen;
END_RCPP
}

RcppExport SEXP _GWmodel_gwr_basic_predict(
    SEXP pcoordsSEXP, SEXP xSEXP, SEXP ySEXP, SEXP coordsSEXP,
    SEXP bwSEXP, SEXP adaptiveSEXP, SEXP kernelSEXP,
    SEXP longlatSEXP, SEXP pSEXP, SEXP thetaSEXP,
    SEXP interceptSEXP, SEXP parallel_typeSEXP, SEXP parallel_argSEXP)
{
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix& >::type pcoords(pcoordsSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const NumericMatrix& >::type coords(coordsSEXP);
    Rcpp::traits::input_parameter< double >::type bw(bwSEXP);
    Rcpp::traits::input_parameter< bool >::type adaptive(adaptiveSEXP);
    Rcpp::traits::input_parameter< size_t >::type kernel(kernelSEXP);
    Rcpp::traits::input_parameter< bool >::type longlat(longlatSEXP);
    Rcpp::traits::input_parameter< double >::type p(pSEXP);
    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< bool >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< size_t >::type parallel_type(parallel_typeSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type parallel_arg(parallel_argSEXP);

    // Logger
    Logger::printer = r_printer;

    // Convert data types
    arma::mat mpcoords = myas(pcoords);
    arma::mat mx = myas(x);
    arma::vec my = myas(y);
    arma::mat mcoords = myas(coords);
    std::vector<int> vpar_args = as< std::vector<int> >(Rcpp::IntegerVector(parallel_arg));

    // Make Spatial Weight
    BandwidthWeight bandwidth(bw, adaptive, BandwidthWeight::KernelFunctionType((size_t)kernel));
    Distance* distance = nullptr;
    if (longlat)
    {
        distance = new CRSDistance(true);
    }
    else
    {
        if (p == 2.0 && theta == 0.0)
        {
            distance = new CRSDistance(false);
        }
        else
        {
            distance = new MinkwoskiDistance(p, theta);
        }
    }
    SpatialWeight spatial(&bandwidth, distance);
    
    // Make Algorithm Object
    GWRBasic algorithm(mx, my, mcoords, spatial, false, intercept);
    switch (ParallelType(size_t(parallel_type)))
    {
    case ParallelType::SerialOnly:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
#ifdef _OPENMP
    case ParallelType::OpenMP:
        algorithm.setParallelType(ParallelType::OpenMP);
        algorithm.setOmpThreadNum(vpar_args[0]);
        break;
#endif
    default:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
    }

    // Return Results
    mat betas = algorithm.predict(mpcoords);

    rcpp_result_gen = mywrap(betas);
    return rcpp_result_gen;
END_RCPP
}

RcppExport SEXP _GWmodel_gwr_multiscale_fit(
    SEXP xSEXP, SEXP ySEXP, SEXP coordsSEXP,
    SEXP bwSEXP, SEXP adaptiveSEXP, SEXP kernelSEXP,
    SEXP longlatSEXP, SEXP pSEXP, SEXP thetaSEXP,
    SEXP optim_bwSEXP, SEXP optim_bw_criterionSEXP, SEXP threasholdSEXP,
    SEXP initial_typeSEXP, SEXP centeredSEXP,
    SEXP criterionSEXP, SEXP hatmatrixSEXP, SEXP interceptSEXP, SEXP retry_timesSEXP,
    SEXP max_iterationsSEXP, SEXP parallel_typeSEXP, SEXP parallel_argSEXP)
{
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const NumericMatrix& >::type coords(coordsSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type bw(bwSEXP);
    Rcpp::traits::input_parameter< LogicalVector >::type adaptive(adaptiveSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type kernel(kernelSEXP);
    Rcpp::traits::input_parameter< LogicalVector >::type longlat(longlatSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type p(pSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< LogicalVector >::type optim_bw(optim_bwSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type optim_bw_criterion(optim_bw_criterionSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type threashold(threasholdSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type initial_type(initial_typeSEXP);
    Rcpp::traits::input_parameter< LogicalVector >::type centered(centeredSEXP);
    Rcpp::traits::input_parameter< size_t >::type criterion(criterionSEXP);
    Rcpp::traits::input_parameter< bool >::type hatmatrix(hatmatrixSEXP);
    Rcpp::traits::input_parameter< bool >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< size_t >::type retry_times(retry_timesSEXP);
    Rcpp::traits::input_parameter< size_t >::type max_iterations(max_iterationsSEXP);
    Rcpp::traits::input_parameter< size_t >::type parallel_type(parallel_typeSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type parallel_arg(parallel_argSEXP);

    // Logger
    Logger::printer = r_printer;

    // Convert data types
    arma::mat mx = myas(x);
    arma::vec my = myas(y);
    arma::mat mcoords = myas(coords);
    std::vector<int> vpar_args = as< std::vector<int> >(Rcpp::IntegerVector(parallel_arg));

    // Make Spatial Weight
    size_t nVar = (size_t)mx.n_cols;
    auto vbw = as< vector<double> >(NumericVector(bw));
    auto vadaptive = as< vector<bool> >(LogicalVector(adaptive));
    auto vkernel = as< vector<int> >(IntegerVector(kernel));
    auto vlonglat = as< vector<bool> >(LogicalVector(longlat));
    auto vp = as< vector<double> >(NumericVector(p));
    auto vtheta = as< vector<double> >(NumericVector(theta));
    auto voptim_bw = as< vector<bool> >(LogicalVector(optim_bw));
    auto voptim_bw_criterion = as< vector<int> >(IntegerVector(optim_bw_criterion));
    auto vinitial_type = as< vector<int> >(IntegerVector(initial_type));
    auto vcentered = as< vector<bool> >(LogicalVector(centered));
    auto vthreshold = as< vector<double> >(NumericVector(threashold));
    vector<SpatialWeight> spatials;
    for (size_t i = 0; i < nVar; i++)
    {
        BandwidthWeight bandwidth(vbw[i], vadaptive[i], BandwidthWeight::KernelFunctionType(vkernel[i]));
        Distance* distance = nullptr;
        if (vlonglat[i]) distance = new CRSDistance(true);
        else
        {
            if (vp[i] == 2.0 && vtheta[i] == 0.0) distance = new CRSDistance(false);
            else distance = new MinkwoskiDistance(vp[i], vtheta[i]);
        }
        spatials.push_back(SpatialWeight(&bandwidth, distance));
    }
    vector<GWRMultiscale::BandwidthInitilizeType> bandwidthInitialize(vinitial_type.size());
    transform(vinitial_type.begin(), vinitial_type.end(), bandwidthInitialize.begin(), [](int x) {
        return GWRMultiscale::BandwidthInitilizeType(x);
    });
    vector<GWRMultiscale::BandwidthSelectionCriterionType> bandwidthSelectionApproach(voptim_bw_criterion.size());
    transform(voptim_bw_criterion.begin(), voptim_bw_criterion.end(), bandwidthSelectionApproach.begin(), [](int x) {
        return GWRMultiscale::BandwidthSelectionCriterionType(x);
    });
    
    // Make Algorithm Object
    GWRMultiscale algorithm(mx, my, mcoords, spatials);
    algorithm.setIndependentVariables(mx);
    algorithm.setDependentVariable(my);
    algorithm.setCoords(mcoords);
    algorithm.setSpatialWeights(spatials);
    algorithm.setPreditorCentered(vcentered);
    algorithm.setBandwidthInitilize(bandwidthInitialize);
    algorithm.setBandwidthSelectionApproach(bandwidthSelectionApproach);
    algorithm.setBandwidthSelectThreshold(vthreshold);
    algorithm.setCriterionType(GWRMultiscale::BackFittingCriterionType(size_t(criterion)));
    algorithm.setHasHatMatrix(hatmatrix);
    algorithm.setBandwidthSelectRetryTimes(retry_times);
    algorithm.setMaxIteration(max_iterations);
    switch (ParallelType(size_t(parallel_type)))
    {
    case ParallelType::SerialOnly:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
#ifdef _OPENMP
    case ParallelType::OpenMP:
        algorithm.setParallelType(ParallelType::OpenMP);
        algorithm.setOmpThreadNum(vpar_args[0]);
        break;
#endif
    default:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
    }
    algorithm.fit();

    // Get bandwidth
    vector<double> bw_value;
    const vector<SpatialWeight>& spatialWeights = algorithm.spatialWeights();
    for (size_t i = 0; i < nVar; i++)
    {
        bw_value.push_back(spatialWeights[i].weight<BandwidthWeight>()->bandwidth());
    }
    
    // Return Results
    mat betas = algorithm.betas();
    vec fitted = sum(mx % betas, 1);
    List result_list = List::create(
        Named("betas") = mywrap(betas),
        Named("diagnostic") = mywrap(algorithm.diagnostic()),
        Named("bw_value") = wrap(bw_value),
        Named("fitted") = mywrap(fitted)
    );

    rcpp_result_gen = result_list;
    return rcpp_result_gen;
END_RCPP
}

RcppExport SEXP _GWmodel_gwdr_fit(
    SEXP xSEXP, SEXP ySEXP, SEXP coordsSEXP,
    SEXP bwSEXP, SEXP adaptiveSEXP, SEXP kernelSEXP,
    SEXP interceptSEXP, SEXP hatmatrixSEXP,
    SEXP parallel_typeSEXP, SEXP parallel_argSEXP,
    SEXP optim_bwSEXP, SEXP optim_bw_criterionSEXP, SEXP optim_threasholdSEXP,
    SEXP optim_stepSEXP, SEXP optim_max_iterSEXP,
    SEXP select_modelSEXP, SEXP select_model_thresholdSEXP)
{
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const NumericMatrix& >::type coords(coordsSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type bw(bwSEXP);
    Rcpp::traits::input_parameter< LogicalVector >::type adaptive(adaptiveSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type kernel(kernelSEXP);
    Rcpp::traits::input_parameter< bool >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< bool >::type hatmatrix(hatmatrixSEXP);
    Rcpp::traits::input_parameter< size_t >::type parallel_type(parallel_typeSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type parallel_arg(parallel_argSEXP);
    Rcpp::traits::input_parameter< bool >::type optim_bw(optim_bwSEXP);
    Rcpp::traits::input_parameter< size_t >::type optim_bw_criterion(optim_bw_criterionSEXP);
    Rcpp::traits::input_parameter< double >::type optim_threashold(optim_threasholdSEXP);
    Rcpp::traits::input_parameter< double >::type optim_step(optim_stepSEXP);
    Rcpp::traits::input_parameter< size_t >::type optim_max_iter(optim_max_iterSEXP);
    Rcpp::traits::input_parameter< bool >::type select_model(select_modelSEXP);
    Rcpp::traits::input_parameter< size_t >::type select_model_threshold(select_model_thresholdSEXP);

    // Logger
    Logger::printer = r_printer;

    // Convert data types
    arma::mat mx = myas(x);
    arma::vec my = myas(y);
    arma::mat mcoords = myas(coords);
    std::vector<int> vpar_args = as< std::vector<int> >(Rcpp::IntegerVector(parallel_arg));

    // Make Spatial Weight
    size_t nDim = (size_t)mcoords.n_cols;
    auto vbw = as< vector<double> >(NumericVector(bw));
    auto vadaptive = as< vector<bool> >(LogicalVector(adaptive));
    auto vkernel = as< vector<int> >(IntegerVector(kernel));
    vector<SpatialWeight> spatials;
    for (size_t i = 0; i < nDim; i++)
    {
        BandwidthWeight bandwidth(vbw[i], vadaptive[i], BandwidthWeight::KernelFunctionType(vkernel[i]));
        OneDimDistance distance;
        spatials.push_back(SpatialWeight(&bandwidth, &distance));
    }
    
    // Make Algorithm Object
    GWDR algorithm(mx, my, mcoords, spatials);
    algorithm.setHasHatMatrix(hatmatrix);
    algorithm.setBandwidthCriterionType(GWDR::BandwidthCriterionType(size_t(optim_bw_criterion)));

    if (select_model)
    {
        algorithm.setEnableIndepVarSelect(true);
        algorithm.setIndepVarSelectThreshold(select_model_threshold);
    }

    if (optim_bw) 
    {
        algorithm.setEnableBandwidthOptimize(true);
        algorithm.setBandwidthOptimizeEps(optim_threashold);
        algorithm.setBandwidthOptimizeStep(optim_step);
        algorithm.setBandwidthOptimizeMaxIter(optim_max_iter);
    }

    switch (ParallelType(size_t(parallel_type)))
    {
    case ParallelType::SerialOnly:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
#ifdef _OPENMP
    case ParallelType::OpenMP:
        algorithm.setParallelType(ParallelType::OpenMP);
        algorithm.setOmpThreadNum(vpar_args[0]);
        break;
#endif
    default:
        algorithm.setParallelType(ParallelType::SerialOnly);
        break;
    }
    algorithm.fit();
    
    // Return Results
    mat betas = algorithm.betas();
    vec fitted = sum(mx % betas, 1);
    List result_list = List::create(
        Named("betas") = mywrap(betas),
        Named("diagnostic") = mywrap(algorithm.diagnostic())
    );
    if (optim_bw)
    {
        vector<double> bw_value;
        const vector<SpatialWeight>& spatialWeights = algorithm.spatialWeights();
        for (size_t i = 0; i < nDim; i++)
        {
            bw_value.push_back(spatialWeights[i].weight<BandwidthWeight>()->bandwidth());
        }
        result_list["bw_value"] = wrap(bw_value);
    }
    if (select_model)
    {
        vector<size_t> sel_vars = algorithm.selectedVariables();
        result_list["variables"] = wrap(sel_vars);
        result_list["model_sel_criterions"] = mywrap(algorithm.indepVarCriterionList());
        mat x = mx.cols(VariableForwardSelector::index2uvec(sel_vars, intercept));
        result_list["fitted"] = mywrap(GWRBasic::Fitted(x, betas));
    }
    else
    {
        result_list["fitted"] = mywrap(GWRBasic::Fitted(mx, betas));
    }

    rcpp_result_gen = result_list;
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_GWmodel_gwr_basic_fit", (DL_FUNC) &_GWmodel_gwr_basic_fit, 18},
    {"_GWmodel_gwr_basic_predict", (DL_FUNC) &_GWmodel_gwr_basic_predict, 13},
    {"_GWmodel_gwr_multiscale_fit", (DL_FUNC) &_GWmodel_gwr_multiscale_fit, 21},
    {"_GWmodel_gwdr_fit", (DL_FUNC) &_GWmodel_gwdr_fit, 17},
    {NULL, NULL, 0}
};

RcppExport void R_init_GWmodel(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
